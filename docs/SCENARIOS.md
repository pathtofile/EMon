# Scenarios

# ETW and WPP Overviews and examples
These great blogs provide a great example of the power of ETW and WPP:
- [Data Source Analysis and Dynamic Windows RE using WPP and TraceLogging](https://posts.specterops.io/data-source-analysis-and-dynamic-windows-re-using-wpp-and-tracelogging-e465f8b653f7)
- [Hidden Treasure: Intrusion Detection with ETW](https://zacbrown.org/2017/04/11/hidden-treasure-intrusion-detection-with-etw-part-1)
- [Tampering with Windows Event Tracing: Background, Offense, and Defense](https://medium.com/palantir/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63)


# Example uses using Sealighter
 - [Tracking process execution](#Tracking%20process%20execution)
 - [Find data in any field](#Find%20data%20in%20any%20field)
 - [Find correlated Events](#Find%20correlated%20Events)
 - [Use Stack Traces](#Use%20Stack%20Traces)
 - [Use Buffering](#Use%20Buffering)

# Tracking process execution
Lets trace a program using [Zac Brown's ideas](https://zacbrown.org/2017/04/11/hidden-treasure-intrusion-detection-with-etw-part-1). Create the Following Config:
```json
{
    "session_properties": {
        "session_name": "Sealighter-Trace",
        "output_format": "file",
        "output_filename": "output.json"
    },
    "user_traces": [
        {
            "trace_name": "powershell_dns",
            "provider_name": "Microsoft-Windows-DNS-Client",
            "filters": {
                "any_of": {
                    "process_name_contains": "powershell.exe"
                }
            }
        },
        {
            "trace_name": "powershell_wmi",
            "provider_name": "Microsoft-Windows-WMI",
            "filters": {
                "any_of": {
                    "process_name_contains": "powershell.exe"
                }
            }
        },
        {
            "trace_name": "powershell_winpshell",
            "provider_name": "Microsoft-Windows-PowerShell",
            "filters": {
                "any_of": {
                    "process_name_contains": "powershell.exe"
                }
            }
        }
    ],
    "kernel_traces": [
        {
            "trace_name": "powershell_kern_image_load",
            "provider_name": "image_load",
            "filters": {
                "any_of": {
                    "process_name_contains": "powershell.exe"
                }
            }
        },
        {
            "trace_name": "powershell_kern_tcpip",
            "provider_name": "network_tcpip",
            "filters": {
                "any_of": {
                    "process_name_contains": "powershell.exe"
                }
            }
        }
    ]
}
```

We can now start Sealighter, Open PowerShell, run mimikatz in it, then stop the trace.

Then we can use Python to parse the events:
```python
import json
events = list()

with open("output.json", "r") as f:
    for line in f:
        events.append(json.loads(line))

for event_string in events:
    event = json.loads(event_string)
    if event["provider_name"] == "MSNT_SystemTrace" and event["task_name"] == "Image":
        # Image Load:
        image_filename = event["properties"]["FileName"]
        print(f"[A] Image Loaded: {image_filename})")

    elif event["provider_name"] == "Microsoft-Windows-PowerShell" and event["event_id"] == 4104:
        # PowerShell Script
        script = event["properties"]["ScriptBlockText"]
        print(f"[B] Script: {script})")
```


----------


# Find data in any field
Let's investigate a WPP trace using [Matt Graeber's WPP blog](https://posts.specterops.io/data-source-analysis-and-dynamic-windows-re-using-wpp-and-tracelogging-e465f8b653f7) as a guide.

Load up his `TLGMetadataParser.psm1` Script in PowerShell, and let's see if there's any WPP providers in `Shell32.dll`:
```powershell
Import-Module .\TLGMetadataParser.psm1
$shell32 = Get-TraceLoggingMetadata -Path C:\Windows\System32\shell32.dll
$shell32.Providers | Format-List
```

In the list of providers, you should see this one:
```
ProviderGUID      : 382b5e24-181e-417f-a8d6-2155f749e724
ProviderName      : Microsoft.Windows.ShellExecute
ProviderGroupGUID : 4f50731a-89cf-4782-b3e0-dce8c90476ba
```

This appears to be something to do with `ShellExecute`, a common way malware can launch programs from VBA, or other scripts.
For example, here's how you can use it from PowerShell:
```powershell
$shellobj = New-Object -ComObject Shell.Application
$shellobj.ShellExecute("notepad.exe", "test.txt")
```

Let's Create a Sealighter trace with two providers:
1. A Process Trace, where we'll get all process starts (Event Id 2)
2. A WPP trace for the ShellExecute provider, searching for any event that contains the string "cmd.exe"
The config will look like this:
```json
{
    "session_properties": {
        "session_name": "Sealighter-Trace",
        "output_format": "stdout"
    },
    "user_traces": [
        {
            "trace_name": "proc_trace",
            "provider_name": "Microsoft-Windows-Kernel-Process",
            "keywords_any": 16,
            "filters": {
                "any_of": {
                    "event_id_is": 1
                }
            }
        },
        {
            "trace_name": "shell32_trace",
            "provider_name": "{382b5e24-181e-417f-a8d6-2155f749e724}",
            "filters": {
                "any_of": {
                    "any_field_contains": "notepad.exe"
                }
            }
        }
    ]
}
```

Start the Sealighter trace, run the PowerShell `.ShellExecute` script, and you should see 2 events similar to the following:
```json
{
    "header": {
        "activity_id": "{636D6229-2DBC-0001-0F21-6E63BC2DD601}",
        "event_flags": 577,
        "event_id": 0,
        "event_name": "ShellExecuteExW",
        "event_opcode": 1,
        "event_version": 0,
        "process_id": 15724,
        "provider_name": "Microsoft.Windows.ShellExecute",
        "task_name": "ShellExecuteExW",
        "thread_id": 16392,
        "timestamp": "2020-05-19 12:08:08Z",
        "trace_name": "shell32_trace"
    },
    "properties": {
        "PartA_PrivTags": 0,
        "dwHotKey": 0,
        "fMask": 0,
        "hMonitor": "0000000000000000",
        "hkeyClass": 0,
        "hwnd": "0000000000000000",
        "lpClass": "",
        "lpDirectory": "",
        "lpFile": "notepad.exe",
        "lpIDList": "0000000000000000",
        "lpParameters": "test.txt",
        "lpVerb": "",
        "nShow": 1,
        "site": 0,
        "wilActivity": "08400000"
    }
}
{
    "header": {
        "activity_id": "{00000000-0000-0000-0000-000000000000}",
        "event_flags": 576,
        "event_id": 1,
        "event_name": "",
        "event_opcode": 1,
        "event_version": 3,
        "process_id": 15724,
        "provider_name": "Microsoft-Windows-Kernel-Process",
        "task_name": "ProcessStart",
        "thread_id": 4564,
        "timestamp": "2020-05-19 12:08:08Z",
        "trace_name": "proc_trace"
    },
    "properties": {
        "CreateTime": "2020-05-19 12:08:08Z",
        "Flags": 0,
        "ImageChecksum": 219193,
        "ImageName": "\\Device\\HarddiskVolume4\\Windows\\System32\\notepad.exe",
        "MandatoryLabel": "Mandatory Label\\High Mandatory Level",
        "PackageFullName": "",
        "PackageRelativeAppId": "",
        "ParentProcessID": 15724,
        "ParentProcessSequenceNumber": 7866,
        "ProcessID": 16144,
        "ProcessSequenceNumber": 8055,
        "ProcessTokenElevationType": 2,
        "ProcessTokenIsElevated": 1,
        "SessionID": 1,
        "TimeDateStamp": 587902357
    }
}
```

In my example, the PID of the PowerShell that ran the command was `15724`.
We can see that PowerShell triggered an event

We can see a generated event that we didn't know existed called `ShellExecuteExW`, which contains the program we ran (`lpFile`) and the arguments (`lpParameters`).

We can also see the information also matches up with the `Microsoft-Windows-Kernel-Process` trace, confirming that this was us that triggered the event.


----------

## Find correlated Events
Activity IDs are unique GUIDs in the event header for a chain of events, and enable correlation of events across time and even across different providers.

To look for providers that use activity IDs, you could use the following filter, to filter out any events that *don't* have an activity ID:
```json
"filters": {
    "none_of": {
        "activity_id_is": "{00000000-0000-0000-0000-000000000000}"
    }
}
```

Then it would be a case of running various ETW or WPP providers, doing "stuff", and seeing if any events get emitted.


### Use Stack Traces
To demonstrate the use of Stack Traces, let's make and trace our own C program that also does `ShellExecute`:
First we compile the following simple x86 C program and name it `shellcaller.exe`:
```c++
#include <Windows.h>
#include <shellapi.h>
#include <stdio.h>

__declspec(noinline)
static void call_com()
{
    // Print the base address to make RE faster
    // You could also find this out by degging the process
    printf("Base address: 0x%p\n", (void*)GetModuleHandleA(NULL));
    ShellExecuteA(NULL, "open", "notepad.exe", NULL, NULL, SW_SHOWNORMAL);
}

int main()
{
    call_com();
    return 0;
}
```

Then, we'll run Sealighter with the same sort of config to trace the Shell32 Events,
but also use `report_stacktrace` to get stack traces:
```json
{
    "session_properties": {
        "session_name": "Sealighter-Trace",
        "output_format": "stdout"
    },
    "user_traces": [
        {
            "trace_name": "shell32_trace",
            "provider_name": "{382b5e24-181e-417f-a8d6-2155f749e724}",
            "report_stacktrace": true,
            "filters": {
                "any_of": {
                    "any_field_contains": "shellcaller.exe"
                }
            }
        }
    ]
}
```

Start Sealighter, and once the trace has started run `shellcaller.exe` - It should launch
a `notepad.exe` process, and you should get an output similar to below (but with different numbers):
```
Base address: 0x00B80000
```

Sealighter should also output an event similar to below (but again with different numbers):
```json
{
    "header": {
        "activity_id": "{6D9D4EDB-33CC-0002-7D4A-A16DCC33D601}",
        "event_flags": 545,
        "event_id": 0,
        "event_name": "ShellExecuteExW",
        "event_opcode": 1,
        "event_version": 0,
        "process_id": 12016,
        "provider_name": "Microsoft.Windows.ShellExecute",
        "task_name": "ShellExecuteExW",
        "thread_id": 5964,
        "timestamp": "2020-05-28 10:20:07Z",
        "trace_name": "ShellExecute-Stacktrace"
    },
    "properties": {
        "PartA_PrivTags": 0,
        "dwHotKey": 0,
        "fMask": 5376,
        "hMonitor": "00000000",
        "hkeyClass": 0,
        "hwnd": "00000000",
        "lpClass": "",
        "lpDirectory": "",
        "lpFile": "notepad.exe",
        "lpIDList": "00000000",
        "lpParameters": "",
        "lpVerb": "open",
        "nShow": 1,
        "site": 7340143,
        "wilActivity": "4C170000"
    },
    "property_types": {
        "PartA_PrivTags": "UINT64",
        "dwHotKey": "UINT32",
        "fMask": "UINT32",
        "hMonitor": "OTHER",
        "hkeyClass": "UINT32",
        "hwnd": "OTHER",
        "lpClass": "STRINGW",
        "lpDirectory": "STRINGW",
        "lpFile": "STRINGW",
        "lpIDList": "OTHER",
        "lpParameters": "STRINGW",
        "lpVerb": "STRINGW",
        "nShow": "INT32",
        "site": "UINT32",
        "wilActivity": "OTHER"
    },
    "stack_trace": [
        "0x7FFA18BAB944",
        "0x7FFA18692E9F",
        "0x7FFA1868902A",
        "0x773817C3",
        "0x773811B9",
        "0x7FFA186838C9",
        "0x7FFA186832BD",
        "0x7FFA18BE266E",
        "0x7FFA18BD12F1",
        "0x7FFA18B84543",
        "0x7FFA18B844EE",
        "0x7740169C",
        "0x773F451B",
        "0x773F43D9",
        "0x76DE9F06",
        "0x76DAEA61",
        "0x76DAE21B",
        "0x76DADFF2",
        "0x76EE05F4",
        "0x76EE0591",
        "0xB8106E",
        "0x7653F989",
        "0x773F7084",
        "0x773F7054"
    ]
}
```
So we see that `shellcaller.exe` did indeed call `ShellExecute` to launch `notepad.exe`
We now also get a stack trace.

In this example, The base in-memory address of `shellcaller.exe` is `0x00B80000`.
We can also see one of the addresses in the stack is `0xB8106E`, 0x106E bytes into the image.

Now, if We open up a tool like [Ghidra](https://ghidra-sre.org), import `shellcaller.exe` into it,
and go `0x106E` bytes into the image, we should see our call to `SHELL32.DLL::ShellExecuteA`.



## Use Buffering
Buffering enables the reporting of many similar events in a time period as one with a count.

For example, Let's create a trace to log process starts, but buffer all process that have the same ImageFileName together, reporting in groups of every 10 seconds. We will use the following config:
```json
{
    "session_properties": {
        "session_name": "Sealighter-Trace",
        "output_format": "stdout",
        "buffering_timout_seconds":  10
    },
    "user_traces": [
        {
            "trace_name": "ProcTrace01",
            "provider_name": "Microsoft-Windows-Kernel-Process",
            "keywords_any": 16,
            "filters": {
                "any_of": {
                    "event_id_is": 1
                }
            },
            "buffers": [
                {
                    "event_id": 1,
                    "max_before_buffering": 0,
                    "properties_to_match": [
                        "ImageName"
                    ]
                }
            ]
        }
    ]
}
```
We have created a `Microsoft-Windows-Kernel-Process` to only look at Event ID 1, i.e. `ProcessStart` events.
We have set the `buffering_timout_seconds` option to 10 seconds.
We have set 1 buffer for Event 1, to match in the Property `ImageName`.

Running this trace, we will get reports once every 10 seconds. Any matching ImageNames will be
rolled into a single event with a `buffered_count` field.

Process with different ImageNames will be their own events.
